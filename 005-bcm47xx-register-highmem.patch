--- a/arch/mips/bcm47xx/prom.c
+++ b/arch/mips/bcm47xx/prom.c
@@ -138,45 +138,68 @@ void early_tlb_init(void)
 void __init bcm47xx_prom_highmem_init(void)
 {
 	unsigned long off = (unsigned long)prom_init;
 	unsigned long extmem = 0;
-	bool highmem_region = false;
-
-	if (WARN_ON(bcm47xx_bus_type != BCM47XX_BUS_TYPE_BCMA))
-		return;
-
-	if (bcm47xx_bus.bcma.bus.chipinfo.id == BCMA_CHIP_ID_BCM4706)
-		highmem_region = true;
-
-	if (lowmem != 128 << 20 || !highmem_region)
-		return;
-
-	early_tlb_init();
-
-	/* Add one temporary TLB entry to map SDRAM Region 2.
-	 *      Physical        Virtual
-	 *      0x80000000      0xc0000000      (1st: 256MB)
-	 *      0x90000000      0xd0000000      (2nd: 256MB)
-	 */
-	add_temporary_entry(ENTRYLO(0x80000000),
-			    ENTRYLO(0x80000000 + (256 << 20)),
-			    EXTVBASE, PM_256M);
-
-	off = EXTVBASE + __pa(off);
-	for (extmem = 128 << 20; extmem < 512 << 20; extmem <<= 1) {
-		if (!memcmp((void *)prom_init, (void *)(off + extmem), 16))
-			break;
-	}
-	extmem -= lowmem;
-
-	early_tlb_init();
-
-	if (!extmem)
-		return;
-
-	pr_warn("Found %lu MiB of extra memory, but highmem is unsupported yet!\n",
-		extmem >> 20);
-
-	/* TODO: Register extra memory */
+	unsigned long mem = lowmem; /* lowmem определена в prom_init_mem() */
+
+	if (WARN_ON(bcm47xx_bus_type != BCM47XX_BUS_TYPE_BCMA))
+		return;
+
+	/* Условие из ASUSWRT: работаем только если найдено 128 МБ в lowmem */
+	if (mem != (128 << 20))
+		return;
+
+	early_tlb_init();
+
+	/*
+	 * Логика из ASUSWRT (prom.c строка 170-174).
+	 * Add one temporary TLB entry to map SDRAM Region 2.
+	 *      Physical        Virtual
+	 *      0x80000000      0xc0000000      (1st: 256MB)
+	 *      0x90000000      0xd0000000      (2nd: 256MB)
+	 */
+
+	add_temporary_entry(ENTRYLO(SI_SDRAM_R2),
+			    ENTRYLO(SI_SDRAM_R2 + (256 << 20)),
+			    EXTVBASE, PM_256M);
+
+	/* Сканирование памяти через новое виртуальное отображение */
+	off = EXTVBASE + __pa(off);
+	for (extmem = 128 << 20; extmem < 512 << 20; extmem <<= 1) {
+		if (!memcmp(prom_init, (void *)(off + extmem), 16))
+			break;
+	}
+	extmem -= mem;
+
+	/* Возвращаем TLB в исходное состояние (как в ASUSWRT) */
+	early_tlb_init();
+
+	if (!extmem)
+		return;
+
+	pr_info("Found %lu MiB of extra memory\n", extmem >> 20);
+
+	/*
+	 * Логика регистрации из ASUSWRT (prom.c строка 243).
+	 * Для процессора MIPS 74K вносится поправка -0x1000.
+	 */
+	{
+		unsigned long region_start;
+		struct cpuinfo_mips *c = &current_cpu_data;
+
+		region_start = SI_SDRAM_R2 + (128 << 20); /* 0x80000000 + 128MB = 0x88000000 */
+
+		if (c->cputype == CPU_74K && (mem == (128 << 20))) {
+			extmem -= 0x1000;
+			region_start -= 0x1000;
+			pr_debug("MIPS 74K: adjusting highmem region by -0x1000\n");
+		}
+
+		pr_info("Registering highmem at phys 0x%lx, size %lu MiB\n",
+			region_start, extmem >> 20);
+
+		/* Используем add_memory_region для совместимости с bootinfo */
+		memblock_add(region_start, extmem);
+	}
 }
 
 #endif /* defined(CONFIG_BCM47XX_BCMA) && defined(CONFIG_HIGHMEM) */
